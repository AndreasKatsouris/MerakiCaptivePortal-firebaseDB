<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Restaurant - GP Analysis Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            text-align: center;
            position: relative;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 1em;
            opacity: 0.9;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .controls h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .filter-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .filter-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-item label {
            font-weight: 600;
            color: #2c3e50;
        }

        select, input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 14px;
            background: white;
            transition: border-color 0.3s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #3498db;
        }

        .reset-btn {
            background: linear-gradient(135deg, #00b894, #00a085);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .reset-btn:hover {
            transform: translateY(-2px);
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .card h3 {
            color: #2c3e50;
            font-size: 1.8em;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .category-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #ecf0f1;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .category-row:hover {
            background-color: rgba(52, 152, 219, 0.05);
        }

        .category-row:last-child {
            border-bottom: none;
        }

        .category-info {
            flex: 1;
        }

        .category-name {
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .category-details {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .category-metrics {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .metric {
            text-align: center;
        }

        .metric-value {
            font-weight: bold;
            font-size: 1.1em;
        }

        .metric-label {
            font-size: 0.8em;
            color: #7f8c8d;
            text-transform: uppercase;
        }

        .gp-bar {
            width: 100px;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .gp-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
        }

        .gp-high { background: linear-gradient(135deg, #00b894, #00a085); }
        .gp-medium { background: linear-gradient(135deg, #fdcb6e, #e17055); }
        .gp-low { background: linear-gradient(135deg, #fd79a8, #e84393); }

        .expandable-content {
            display: none;
            padding: 20px;
            background: rgba(52, 152, 219, 0.05);
            border-radius: 10px;
            margin-top: 10px;
        }

        .expandable-content.show {
            display: block;
        }

        .pos-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .pos-category:last-child {
            border-bottom: none;
        }

        .insights {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .insights h2 {
            font-size: 2em;
            margin-bottom: 25px;
            text-align: center;
        }

        .insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .insight-card {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .insight-card h4 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #ffffff;
        }

        .insight-card ul {
            list-style: none;
            padding: 0;
        }

        .insight-card li {
            margin-bottom: 10px;
            padding-left: 20px;
            position: relative;
        }

        .insight-card li:before {
            content: "üí°";
            position: absolute;
            left: 0;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            
            .category-metrics {
                flex-direction: column;
                gap: 10px;
            }
            
            .filter-group {
                flex-direction: column;
                align-items: stretch;
            }
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }

        .sort-indicator {
            margin-left: 10px;
            opacity: 0.5;
        }

        .sort-indicator.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåä GP Analysis Dashboard</h1>
            <p>Compare your theoretical GP% (based on sales mix) vs actual food cost performance</p>
            <div style="margin-top: 15px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 10px;">
                <strong>üí° Key Insight:</strong> Upload your sales data and menu costs to see what your GP% SHOULD be based on your sales mix, then compare this to your actual food cost % to identify operational gaps and improvement opportunities.
            </div>
            <div class="summary-stats">
                <div class="stat-card">
                    <div class="stat-value">58.5%</div>
                    <div class="stat-label">Overall GP%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">R27,920</div>
                    <div class="stat-label">Total Sales</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">R16,333</div>
                    <div class="stat-label">Total GP Rands</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">93.2%</div>
                    <div class="stat-label">Data Coverage</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <h3>üìÅ Data Upload</h3>
            <div style="margin-bottom: 15px; padding: 15px; background: #e8f4f8; border-radius: 10px; border-left: 4px solid #3498db;">
                <h4 style="margin-bottom: 10px; color: #2c3e50; font-size: 1.1em;">üìã Required Data Format:</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 0.9em;">
                    <div>
                        <strong>Sales Data should include:</strong>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li>Item/Product names</li>
                            <li>Category</li>
                            <li>Sales amount (R)</li>
                            <li>Quantity sold</li>
                        </ul>
                    </div>
                    <div>
                        <strong>Menu Cost Data should include:</strong>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li>Item/Product names</li>
                            <li>Category</li>
                            <li>Food cost per item (R)</li>
                            <li>Selling price (R)</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="upload-section" style="margin-bottom: 25px; padding: 20px; border: 2px dashed #3498db; border-radius: 15px; background: rgba(52, 152, 219, 0.05);">
                <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
                    <div class="filter-item">
                        <label for="salesFile">Upload Sales Data (XLSX/CSV):</label>
                        <input type="file" id="salesFile" accept=".xlsx,.xls,.csv" style="border: none; background: transparent;">
                    </div>
                    <div class="filter-item">
                        <label for="menuFile">Upload Menu Cost Data (XLSX/CSV):</label>
                        <input type="file" id="menuFile" accept=".xlsx,.xls,.csv" style="border: none; background: transparent;">
                    </div>
                    <button class="reset-btn" onclick="processUploadedFiles()" id="processBtn" disabled>üîÑ Process Files</button>
                    <button class="reset-btn" onclick="loadSampleData()" style="background: linear-gradient(135deg, #74b9ff, #0984e3);">üìä Load Sample Data</button>
                    <button class="reset-btn" onclick="showAnalysisDetails()" id="analysisBtn" style="background: linear-gradient(135deg, #00b894, #00a085); display: none;">üìã Analysis Details</button>
                    <button class="reset-btn" onclick="showUnmatchedItems()" id="unmatchedBtn" style="background: linear-gradient(135deg, #fd79a8, #e84393); display: none;">‚ùå Unmatched Items</button>
                </div>
                <div id="uploadStatus" style="margin-top: 15px; font-size: 0.9em; color: #7f8c8d;"></div>
                <div id="dataPreview" style="margin-top: 20px; padding: 15px; background: #e8f5e8; border-radius: 10px; border-left: 4px solid #27ae60; display: none;">
                    <h4 style="margin-bottom: 10px; color: #2c3e50;">üìã Data Preview</h4>
                    <div id="previewContent" style="font-size: 0.9em; color: #2c3e50;"></div>
                    <button onclick="hideDataPreview()" style="margin-top: 10px; padding: 5px 10px; background: #27ae60; color: white; border: none; border-radius: 5px; cursor: pointer;">Hide Preview</button>
                </div>
                <div id="columnMapping" style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 10px; border-left: 4px solid #ffc107; display: none;">
                    <h4 style="margin-bottom: 10px; color: #2c3e50;">üîó Column Mapping</h4>
                    <p style="margin-bottom: 15px; color: #856404;">Map your file columns to the required data fields:</p>
                    <div id="mappingContent" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;"></div>
                    <div style="margin-top: 20px; text-align: center;">
                        <button onclick="applyColumnMapping()" style="padding: 10px 20px; background: #ffc107; color: #212529; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; margin-right: 10px;">Apply Mapping & Process</button>
                        <button onclick="hideColumnMapping()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;">Cancel</button>
                    </div>
                </div>
                <div id="debugSection" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px; border-left: 4px solid #3498db; display: none;">
                    <h4 style="margin-bottom: 10px; color: #2c3e50;">üîç Debug Information</h4>
                    <div id="debugLog" style="font-family: monospace; font-size: 0.8em; color: #2c3e50; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
                    <button onclick="clearDebugLog()" style="margin-top: 10px; padding: 5px 10px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer;">Clear Debug</button>
                </div>
            </div>
            
            <h3>üîç Filter & Sort Controls</h3>
            <div class="filter-group">
                <div class="filter-item" style="flex: 1; max-width: 300px;">
                    <label>Categories to Include:</label>
                    <div id="categoryCheckboxes" style="max-height: 150px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px; padding: 10px; background: white;">
                        <!-- Checkboxes will be populated dynamically -->
                    </div>
                    <div style="margin-top: 5px;">
                        <button onclick="selectAllCategories()" style="font-size: 0.8em; padding: 2px 8px; margin-right: 5px; border: 1px solid #ddd; background: #f8f9fa; border-radius: 3px; cursor: pointer;">Select All</button>
                        <button onclick="deselectAllCategories()" style="font-size: 0.8em; padding: 2px 8px; border: 1px solid #ddd; background: #f8f9fa; border-radius: 3px; cursor: pointer;">Deselect All</button>
                    </div>
                </div>
                <div class="filter-item">
                    <label for="gpFilter">GP% Range:</label>
                    <select id="gpFilter">
                        <option value="all">All GP%</option>
                        <option value="high">High (70%+)</option>
                        <option value="medium">Medium (50-70%)</option>
                        <option value="low">Low (<50%)</option>
                    </select>
                </div>
                <div class="filter-item">
                    <label for="salesFilter">Min Sales:</label>
                    <input type="number" id="salesFilter" placeholder="e.g. 1000" min="0">
                </div>
                <div class="filter-item">
                    <label for="sortBy">Sort By:</label>
                    <select id="sortBy">
                        <option value="sales">Sales (High to Low)</option>
                        <option value="gp_percent">GP% (High to Low)</option>
                        <option value="gp_rands">GP Rands (High to Low)</option>
                        <option value="name">Category Name (A-Z)</option>
                    </select>
                </div>
                <button class="reset-btn" onclick="resetFilters()">Reset All</button>
            </div>
        </div>

        <div class="analysis-grid">
            <div class="card full-width">
                <h3>üìä Category Performance Analysis</h3>
                <div id="categoryList">
                    <!-- Categories will be populated here -->
                </div>
            </div>
        </div>

        <div class="insights">
            <h2>üí° GP Analysis Insights & Operational Gaps</h2>
            <div class="insights-grid">
                <div class="insight-card">
                    <h4>üéØ Theoretical vs Actual Performance</h4>
                    <ul>
                        <li>Your sales mix suggests 58.5% theoretical GP</li>
                        <li>Compare this to your actual food cost %</li>
                        <li>Gaps indicate operational challenges</li>
                        <li>Large gaps = significant improvement opportunity</li>
                    </ul>
                </div>
                <div class="insight-card">
                    <h4>üîç What GP Gaps Usually Indicate</h4>
                    <ul>
                        <li>Portion control issues (over-portioning)</li>
                        <li>Recipe deviations or substitutions</li>
                        <li>Inventory shrinkage or waste</li>
                        <li>Supplier cost increases not reflected in pricing</li>
                    </ul>
                </div>
                <div class="insight-card">
                    <h4>üí∞ High-Impact Categories</h4>
                    <ul>
                        <li>Focus on high-volume, high-GP categories first</li>
                        <li>Beverages typically offer best margins</li>
                        <li>Large sales volume = biggest impact potential</li>
                        <li>Monitor low-GP categories for operational issues</li>
                    </ul>
                </div>
                <div class="insight-card">
                    <h4>üìä Action Framework</h4>
                    <ul>
                        <li>Compare your actual food cost to theoretical GP</li>
                        <li>Investigate categories with largest gaps</li>
                        <li>Implement portion control measures</li>
                        <li>Review supplier costs and menu pricing</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- XLSX Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <script>
        // Global variables for data processing
        let salesData = [];
        let menuCostData = [];
        let processedData = [];
        
        // Category data from analysis (sample data)
        const categoryData = [
            { name: "Platters & Sharing", sales: 11625, gp_percent: 55.0, gp_rands: 6399, items: 15, pos_categories: ["PLATTE", "PLT/SS"] },
            { name: "Seafood Mains", sales: 4910, gp_percent: 51.5, gp_rands: 2530, items: 12, pos_categories: ["FISH", "PRAWN", "CALAMA"] },
            { name: "Cold Beverages", sales: 2720, gp_percent: 80.6, gp_rands: 2192, items: 18, pos_categories: ["CBEV", "COOL", "D/DRIN"] },
            { name: "Combos", sales: 2230, gp_percent: 61.9, gp_rands: 1381, items: 8, pos_categories: ["COMBOS"] },
            { name: "Alcoholic Beverages", sales: 1890, gp_percent: 53.3, gp_rands: 1008, items: 12, pos_categories: ["BEER", "DRGHT", "W/WINE", "R/WINE", "CTAILS"] },
            { name: "Starters & Small Plates", sales: 1550, gp_percent: 76.8, gp_rands: 1190, items: 8, pos_categories: ["START", "TOPUP"] },
            { name: "Sushi & Asian", sales: 905, gp_percent: 63.4, gp_rands: 574, items: 8, pos_categories: ["MAKI", "C/ROLL", "SIGNTR", "RB/ROL"] },
            { name: "Salads", sales: 780, gp_percent: 57.4, gp_rands: 447, items: 3, pos_categories: ["SALAD"] },
            { name: "Promotions", sales: 725, gp_percent: 20.0, gp_rands: 145, items: 1, pos_categories: ["PROMO"] },
            { name: "Desserts", sales: 255, gp_percent: 68.4, gp_rands: 174, items: 3, pos_categories: ["DESS"] },
            { name: "Hot Beverages", sales: 250, gp_percent: 82.8, gp_rands: 207, items: 4, pos_categories: ["HBEV"] },
            { name: "Sides", sales: 80, gp_percent: 101.8, gp_rands: 81, items: 2, pos_categories: ["SIDE"] }
        ];

        let filteredData = [...categoryData];

        // File upload and processing functions
        function handleFileUpload() {
            const salesFile = document.getElementById('salesFile').files[0];
            const menuFile = document.getElementById('menuFile').files[0];
            const processBtn = document.getElementById('processBtn');
            
            if (salesFile && menuFile) {
                processBtn.disabled = false;
                updateUploadStatus(`‚úÖ Files selected: ${salesFile.name}, ${menuFile.name}`);
                debugLog(`Files selected: Sales: ${salesFile.name}, Menu: ${menuFile.name}`);
            } else {
                processBtn.disabled = true;
                updateUploadStatus('Please select both sales data and menu cost files');
            }
        }

        function processUploadedFiles() {
            const salesFile = document.getElementById('salesFile').files[0];
            const menuFile = document.getElementById('menuFile').files[0];
            
            if (!salesFile || !menuFile) {
                updateUploadStatus('‚ùå Please select both files');
                return;
            }
            
            updateUploadStatus('üîÑ Processing files...');
            debugLog('Starting file processing...');
            
            Promise.all([
                readFile(salesFile),
                readFile(menuFile)
            ]).then(([salesResult, menuResult]) => {
                debugLog('Files read successfully');
                
                // Show raw data preview first
                showDataPreview(salesResult, menuResult);
                
                processSalesData(salesResult);
                processMenuData(menuResult);
                
                if (salesData.length === 0 && menuCostData.length === 0) {
                    updateUploadStatus('‚ö†Ô∏è Automatic column mapping failed. Please use the column mapping tool below.');
                    showColumnMapping(salesResult, menuResult);
                    return;
                }
                
                calculateGPAnalysis();
                
                if (processedData.length === 0) {
                    updateUploadStatus('‚ùå Could not match sales data with menu costs. Check item names and try again.');
                    return;
                }
                
                updateDashboard();
                updateUploadStatus('‚úÖ Files processed successfully!');
                
                // Show analysis details button
                document.getElementById('analysisBtn').style.display = 'inline-block';
                
                // Show unmatched items button if there are unmatched items
                const metadata = window.analysisMetadata || {};
                if (metadata.unmatchedItems > 0) {
                    document.getElementById('unmatchedBtn').style.display = 'inline-block';
                }
            }).catch(error => {
                debugLog(`Error processing files: ${error.message}`);
                updateUploadStatus(`‚ùå Error processing files: ${error.message}`);
            });
        }

        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                if (file.name.toLowerCase().endsWith('.csv')) {
                    // Handle CSV files
                    reader.onload = function(e) {
                        try {
                            const csv = e.target.result;
                            const jsonData = parseCSV(csv);
                            resolve(jsonData);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.readAsText(file);
                } else {
                    // Handle Excel files
                    reader.onload = function(e) {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, {type: 'array'});
                            const firstSheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet);
                            resolve(jsonData);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.readAsArrayBuffer(file);
                }
                
                reader.onerror = reject;
            });
        }

        function parseCSV(csv) {
            // Detect delimiter
            const delimiters = [',', ';', '\t'];
            let delimiter = ',';
            let maxFields = 0;
            
            delimiters.forEach(del => {
                const testLine = csv.split('\n')[0];
                const fields = testLine.split(del).length;
                if (fields > maxFields) {
                    maxFields = fields;
                    delimiter = del;
                }
            });
            
            debugLog(`Detected CSV delimiter: '${delimiter}'`);
            
            const lines = csv.split('\n');
            if (lines.length === 0) return [];
            
            // Parse headers
            const headers = parseCSVLine(lines[0], delimiter);
            debugLog(`CSV Headers: ${headers.join(', ')}`);
            
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim()) {
                    const values = parseCSVLine(lines[i], delimiter);
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] || '';
                    });
                    data.push(row);
                }
            }
            
            return data;
        }

        function parseCSVLine(line, delimiter) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Escaped quote
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                    }
                } else if (char === delimiter && !inQuotes) {
                    // Field separator
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // Add final field
            result.push(current.trim());
            
            return result;
        }

        function processSalesData(data) {
            debugLog('Processing sales data...');
            debugLog(`Raw sales data sample: ${JSON.stringify(data.slice(0, 3), null, 2)}`);
            
            if (data.length === 0) {
                debugLog('‚ùå No sales data found');
                return;
            }
            
            // Log available columns
            const columns = Object.keys(data[0]);
            debugLog(`Available sales columns: ${columns.join(', ')}`);
            
            salesData = data.map(row => {
                // More flexible column mapping
                const item = row['Menu_Item'] || row['Item'] || row['Product'] || row['Name'] || row['Description'] || 
                           row['PLU Description'] || row['Item Description'] || '';
                const category = row['category'] || row['CATEGORY'] || row['Category'] || row['Cat'] || row['Group'] || row['Department'] || '';
                const pluCode = row['Plu_Code'] || row['PLU_Code'] || row['PLU'] || row['Code'] || row['Item Code'] || '';
                const sales = parseFloat(row['SalesTotal_Excl__Tax1'] || row['SalesTotal_Inc__Tax1'] || 
                                       row['Sales'] || row['Amount'] || row['Total'] || row['Revenue'] || 
                                       row['Sales Amount'] || row['Net Sales'] || 0);
                const quantity = parseInt(row['Quantity'] || row['Qty'] || row['Units'] || row['Count'] || 0);
                const price = parseFloat(row['Price'] || row['Unit Price'] || row['Selling Price'] || 
                                       row['Average Price'] || 0);
                
                return {
                    item: item.toString().trim(),
                    category: category.toString().trim(),
                    pluCode: pluCode.toString().trim(),
                    sales: isNaN(sales) ? 0 : sales,
                    quantity: isNaN(quantity) ? 0 : quantity,
                    price: isNaN(price) ? 0 : price,
                    originalRow: row // Keep original for debugging
                };
            }).filter(item => item.item && (item.sales > 0 || item.quantity > 0));
            
            debugLog(`Processed ${salesData.length} sales records`);
            debugLog(`Sales data sample: ${JSON.stringify(salesData.slice(0, 3), null, 2)}`);
            
            // Debug PLU code extraction
            const withPLU = salesData.filter(item => item.pluCode && item.pluCode.trim() !== '').length;
            debugLog(`üìã Sales data PLU analysis: ${withPLU}/${salesData.length} items have PLU codes`);
        }

        function processMenuData(data) {
            debugLog('Processing menu cost data...');
            debugLog(`Raw menu data sample: ${JSON.stringify(data.slice(0, 3), null, 2)}`);
            
            if (data.length === 0) {
                debugLog('‚ùå No menu data found');
                return;
            }
            
            // Log available columns
            const columns = Object.keys(data[0]);
            debugLog(`Available menu columns: ${columns.join(', ')}`);
            
            menuCostData = data.map(row => {
                // More flexible column mapping
                const item = row['Product'] || row['Item'] || row['Name'] || row['Description'] || 
                           row['Menu Item'] || row['Item Name'] || '';
                const category = row['Category'] || row['Cat'] || row['Group'] || row['Department'] || '';
                const pluCode = row['PLU'] || row['PLU_Code'] || row['Plu_Code'] || row['Code'] || row['Item Code'] || '';
                
                // Helper function to parse currency values (handles R9.80, $10.50, etc.)
                const parseCurrency = (value) => {
                    if (!value) return 0;
                    const stringValue = value.toString().trim();
                    // Remove currency symbols and parse
                    const cleanValue = stringValue.replace(/[R$¬£‚Ç¨,\s]/g, '');
                    const parsed = parseFloat(cleanValue);
                    return isNaN(parsed) ? 0 : parsed;
                };
                
                const cost = parseCurrency(row['2025 Meal Cost'] || row[' 2025 Meal Cost '] || 
                                         row['Cost'] || row['Food Cost'] || row['Recipe Cost'] || 
                                         row['Unit Cost'] || row['Item Cost'] || 0);
                const price = parseCurrency(row['2025 Winter Menu Price'] || row[' 2025 Winter Menu Price '] ||
                                          row['Price'] || row['Selling Price'] || row['Menu Price'] || 
                                          row['Sale Price'] || 0);
                
                // Debug first few rows to verify currency parsing
                if (menuCostData.length < 3) {
                    debugLog(`Menu item "${item}": cost="${cost}" (from "${row['2025 Meal Cost']}"), price="${price}" (from "${row['2025 Winter Menu Price']}")`);
                }
                
                return {
                    item: item.toString().trim(),
                    category: category.toString().trim(),
                    pluCode: pluCode.toString().trim(),
                    cost: isNaN(cost) ? 0 : cost,
                    price: isNaN(price) ? 0 : price,
                    originalRow: row // Keep original for debugging
                };
            }).filter(item => item.item && item.cost > 0);
            
            debugLog(`Processed ${menuCostData.length} menu cost records`);
            debugLog(`Menu data sample: ${JSON.stringify(menuCostData.slice(0, 3), null, 2)}`);
            
            // Debug PLU code extraction
            const withPLU = menuCostData.filter(item => item.pluCode && item.pluCode.trim() !== '').length;
            debugLog(`üìã Menu data PLU analysis: ${withPLU}/${menuCostData.length} items have PLU codes`);
        }

        // Item classification patterns for identifying modifiers vs actual menu items
        const MODIFIER_PATTERNS = {
            cookingMethods: [], // Removed cooking methods as they're often part of dish names
            doneness: ['rare', 'medium', 'well done', 'medium rare'],
            instructions: ['dont make', "don't make", 'call waiter', 'watch out', 'wait for waiter', 'send', 'cutlr', 'allergic'],
            modifiers: ['extra', 'no ', 'half', 'double', 'add', 'less', 'more', 'on the side', 'separate'],
            separators: ['---', 'as main', 'end', 'one plate', 'in 1 plate'],
            beverageModifiers: ['ice', 'froth', 'rocks', 'no ice'], // Removed 'hot' and 'cold' as they're often dish names
            sides: ['rice', 'salad', 'bread', 'sauce'], // Kept sides that are commonly separate items
            preparations: ['head only', 'out of shell', 'on one pan', 'starch separate'],
            complimentary: ['comp ', 'free', 'complimentary'],
            specialInstructions: ['aggregator', 'delivery fee', 'vendor']
        };

        // Exception patterns for complete dish names that contain modifier words but are actual menu items
        const DISH_NAME_EXCEPTIONS = [
            // Fish & Chips variations - these are complete dishes, not modifiers
            /\b(fam|family)\s+fish\s*&?\s*chips?\b/i,
            /\bfish\s*&?\s*chips?\b/i,
            /\b(hake|salmon|kingklip|sole|ob\s*select)\s+.*\bchips?\b/i,
            /\bchips?\s+(hake|salmon|kingklip|sole)/i,
            
            // Prawn dishes - actual menu items, not raw preparations
            /\b(classic\s+)?(king|queen|prince)\s+prawns?\s*\d*/i,
            /\bprawns?\s+\d+/i,
            /\d+\s+prawns?/i,
            /\bprawn\s+(burger|curry|pasta|salad|platter)/i,
            /\bpanko\s+prawns?/i,
            /\bsaucy\s+prawns?/i,
            /\bp\s+prawn/i, // P Prawn variations
            
            // Fish dishes that might contain cooking method words but are complete dishes
            /\b(grilled|fried)\s+(salmon|hake|kingklip|sole|seabream|calamari)\s+\d+g/i,
            /\bwhole\s+grilled\s+seabream/i,
            /\b(salmon|hake|kingklip)\s+(sa|nz)\s+\d+g/i,
            
            // Complete salad dishes
            /(salmon|chicken|prawn|village|house|chunky|pickled)\s+.*salad/i,
            /salad\s+(to\s+share|for\s+\d+)/i,
            
            // Burger dishes
            /(fish|prawn|calamari|halloumi|panko)\s+.*burger/i,
            
            // Maki and sushi items
            /\d+\s+(maki|nigiri|sashimi|cal\s+roll)/i,
            /(maki|nigiri|sashimi)\s+.*\d+/i,
            
            // Platter dishes
            /\b.*platter\b/i,
            /\bfor\s+\d+/i,
            /\bbite\s+of\s+the\s+ocean/i,
            /\bfull\s+deck/i,
            
            // Ice cream and desserts (contains "ice" but are menu items)
            /\bice\s+cream/i,
            /\bmilkshake/i,
            
            // Rice dishes when part of complete dish names
            /\b(ob|basmati)\s+rice\b/i,
            /\brice\s+(t\s+up|top?\s+up)/i,
            
            // Chips as part of complete dishes
            /\bchips?\s+(top?\s+up|t\s+up)/i,
            /\bkid\s+chips?\b/i,
            /\bcrispy\s+chips?\b/i,
            
            // Hot/Cold beverages that are menu items
            /\bhot\s+(chocolate|water|milk)/i,
            /\bcold\s+milk/i,
            
            // Other specific patterns
            /\b.*\s+&\s+.*\b/i, // Items with & (like combos)
            /\b.*\s+\d+g\b/i,   // Items with weight specifications
        ];

        // Check if an item is likely a modifier/instruction rather than a menu item
        function isModifierItem(itemName) {
            const name = itemName.toLowerCase().trim();
            
            // First check if this matches any dish name exceptions
            for (const exception of DISH_NAME_EXCEPTIONS) {
                if (exception.test(name)) {
                    return { isModifier: false }; // This is a complete dish, not a modifier
                }
            }
            
            // Check for very short names (likely codes)
            if (name.length < 3) {
                return { isModifier: true, type: 'code', pattern: 'short_name' };
            }
            
            // Special case: standalone "chips" without context is likely a modifier
            if (name === 'chips' || name === 'chip') {
                return { isModifier: true, type: 'sides', pattern: 'chips' };
            }
            
            // Check against all modifier patterns
            for (const [category, patterns] of Object.entries(MODIFIER_PATTERNS)) {
                for (const pattern of patterns) {
                    if (name.includes(pattern) || name === pattern) {
                        return { isModifier: true, type: category, pattern: pattern };
                    }
                }
            }
            
            // Additional pattern checks
            if (name.match(/^no[\s-]/i) || name.startsWith('dont') || name.startsWith('cutlr') ||
                name.includes('allergic') || name.match(/---/) || name.includes('top up') ||
                name.includes('make') || name.includes('waiter') || name.includes('watch')) {
                return { isModifier: true, type: 'instruction', pattern: 'pattern_match' };
            }
            
            // Check for common POS modifiers by name patterns (but be more restrictive)
            const singleWordModifiers = ['well', 'medium', 'rare', 'hot', 'cold', 'vanilla', 'extra', 'double', 'half'];
            if (singleWordModifiers.includes(name) || 
                (name.split(' ').length === 1 && name.length < 6 && !name.match(/\d/) && 
                 !name.includes('prawn') && !name.includes('fish') && !name.includes('chip'))) {
                return { isModifier: true, type: 'single_word_modifier', pattern: name };
            }
            
            return { isModifier: false };
        }

        function calculateGPAnalysis() {
            debugLog('üîç Starting intelligent GP analysis...');
            
            if (salesData.length === 0) {
                debugLog('‚ùå No sales data to analyze');
                updateUploadStatus('‚ùå No valid sales data found');
                return;
            }
            
            if (menuCostData.length === 0) {
                debugLog('‚ùå No menu cost data to analyze');
                updateUploadStatus('‚ùå No valid menu cost data found');
                return;
            }
            
            // Process all sales items as menu items (no modifier filtering)
            const actualMenuItems = [...salesData];
            const modifierItems = []; // Keep empty for compatibility
            const unmatchedItems = [];
            
            debugLog(`üìã Processing all sales items as potential menu items:`);
            debugLog(`   ‚Ä¢ ${actualMenuItems.length} total items to match`);
            
            // Now match only actual menu items
            let matchedCount = 0;
            const matchedData = actualMenuItems.map(saleItem => {
                // Try different matching strategies with PLU code as highest priority
                let menuItem = null;
                let matchScore = 0;
                
                // 0. PLU Code match (highest priority - exact match)
                if (saleItem.pluCode && saleItem.pluCode.trim() !== '') {
                    menuItem = menuCostData.find(menuItem => 
                        menuItem.pluCode && menuItem.pluCode.trim() === saleItem.pluCode.trim()
                    );
                    if (menuItem) {
                        matchScore = 1.0;
                        debugLog(`üéØ PLU match: ${saleItem.item} (PLU: ${saleItem.pluCode}) ‚Üí ${menuItem.item}`);
                    }
                }
                
                // 1. Exact item name match (only for very close matches - fallback if no PLU match)
                if (!menuItem) {
                    menuItem = menuCostData.find(menuItem => 
                        menuItem.item.toLowerCase().trim() === saleItem.item.toLowerCase().trim()
                    );
                    if (menuItem) {
                        matchScore = 0.9;
                        debugLog(`üìù Exact name match: ${saleItem.item} ‚Üí ${menuItem.item}`);
                    }
                }
                
                // Note: Removed fuzzy matching to focus on PLU accuracy
                // Only use exact matches to avoid incorrect pairings
                
                if (menuItem && matchScore >= 0.8) {
                    matchedCount++;
                    debugLog(`‚úÖ Matched: "${saleItem.item}" ‚Üí "${menuItem.item}" (${(matchScore*100).toFixed(0)}%)`);
                    
                    return {
                        ...saleItem,
                        cost: menuItem.cost,
                        menuPrice: menuItem.price,
                        matched: true,
                        matchedWith: menuItem.item,
                        matchScore: matchScore
                    };
                } else {
                    unmatchedItems.push(saleItem);
                    debugLog(`‚ùå No match found: ${saleItem.item}`);
                    return null;
                }
            }).filter(item => item !== null);
            
            const menuItemMatchRate = actualMenuItems.length > 0 ? 
                ((matchedCount / actualMenuItems.length) * 100).toFixed(1) : 0;
                
            debugLog(`üéØ Matching Results:`);
            debugLog(`   ‚Ä¢ ${matchedCount}/${actualMenuItems.length} menu items matched (${menuItemMatchRate}%)`);
            debugLog(`   ‚Ä¢ ${unmatchedItems.length} items remain unmatched`);
            
            // Collect and report unmatched items
            const actualUnmatched = actualMenuItems.filter(saleItem => {
                return !matchedData.some(matched => 
                    matched && matched.item === saleItem.item && matched.pluCode === saleItem.pluCode
                );
            });
            
            if (actualUnmatched.length > 0) {
                debugLog(`\nüö´ UNMATCHED SALES ITEMS (${actualUnmatched.length} items):`);
                debugLog(`=====================================`);
                
                // Group unmatched by category for better organization
                const unmatchedByCategory = {};
                actualUnmatched.forEach(item => {
                    const cat = item.category || 'No Category';
                    if (!unmatchedByCategory[cat]) unmatchedByCategory[cat] = [];
                    unmatchedByCategory[cat].push(item);
                });
                
                // Group unmatched items by PLU availability for better insights
                const unmatchedWithPLU = actualUnmatched.filter(item => item.pluCode && item.pluCode.trim() !== '');
                const unmatchedWithoutPLU = actualUnmatched.filter(item => !item.pluCode || item.pluCode.trim() === '');
                
                debugLog(`\nüîç UNMATCHED ITEMS ANALYSIS:`);
                debugLog(`=====================================`);
                debugLog(`üìä Summary: ${actualUnmatched.length} unmatched items (${unmatchedWithPLU.length} with PLU, ${unmatchedWithoutPLU.length} without PLU)`);
                
                if (unmatchedWithPLU.length > 0) {
                    debugLog(`\nüè∑Ô∏è UNMATCHED WITH PLU CODES (${unmatchedWithPLU.length} items):`);
                    debugLog(`These items have PLU codes but no matching menu cost data:`);
                    
                    // Sort by sales value to show highest impact first
                    const sortedUnmatched = unmatchedWithPLU.sort((a, b) => b.sales - a.sales);
                    
                    // Show top 10 highest value unmatched items
                    const topUnmatched = sortedUnmatched.slice(0, 10);
                    debugLog(`\n   üìä TOP ${Math.min(10, sortedUnmatched.length)} HIGHEST VALUE UNMATCHED:`);
                    topUnmatched.forEach((item, index) => {
                        const salesInfo = `R${item.sales.toFixed(2)} (${item.quantity}x)`;
                        debugLog(`   ${index + 1}. ${item.item} [PLU: ${item.pluCode}] - ${salesInfo}`);
                    });
                    
                    if (sortedUnmatched.length > 10) {
                        debugLog(`\n   ... and ${sortedUnmatched.length - 10} more unmatched items`);
                        debugLog(`   üí° Total unmatched sales value: R${sortedUnmatched.reduce((sum, item) => sum + item.sales, 0).toFixed(2)}`);
                    }
                    
                    // Create comprehensive PLU list for menu cost file creation
                    debugLog(`\nüìã COMPLETE PLU LIST FOR MENU COST FILE:`);
                    debugLog(`=====================================`);
                    debugLog(`Copy the PLU codes below to add to your menu cost file:`);
                    debugLog(`\nPLU_Code,Item_Name,Sales_Value,Quantity`);
                    
                    sortedUnmatched.forEach(item => {
                        debugLog(`${item.pluCode},"${item.item}",${item.sales.toFixed(2)},${item.quantity}`);
                    });
                    
                    debugLog(`\nüìä PLU SUMMARY:`);
                    debugLog(`   ‚Ä¢ Total PLU codes needed: ${sortedUnmatched.length}`);
                    debugLog(`   ‚Ä¢ Total unmatched sales impact: R${sortedUnmatched.reduce((sum, item) => sum + item.sales, 0).toFixed(2)}`);
                    debugLog(`   ‚Ä¢ Total unmatched quantity: ${sortedUnmatched.reduce((sum, item) => sum + item.quantity, 0)} items`);
                    debugLog(`=====================================`);
                }
                
                if (unmatchedWithoutPLU.length > 0) {
                    debugLog(`\n‚ùì UNMATCHED WITHOUT PLU CODES (${unmatchedWithoutPLU.length} items):`);
                    debugLog(`These items need PLU codes assigned for proper matching:`);
                    
                    // Group by category for better organization
                    const noPluByCategory = unmatchedWithoutPLU.reduce((acc, item) => {
                        const category = item.category || 'Uncategorized';
                        if (!acc[category]) acc[category] = [];
                        acc[category].push(item);
                        return acc;
                    }, {});
                    
                    Object.entries(noPluByCategory).forEach(([category, items]) => {
                        debugLog(`\n   üìÇ ${category} (${items.length} items):`);
                        items.forEach(item => {
                            const salesInfo = `R${item.sales.toFixed(2)} (${item.quantity}x)`;
                            debugLog(`     ‚Ä¢ ${item.item} - ${salesInfo}`);
                        });
                    });
                }
                
                debugLog(`\nüí° IMPROVEMENT RECOMMENDATIONS:`);
                if (unmatchedWithPLU.length > 0) {
                    debugLog(`   üè∑Ô∏è Add ${unmatchedWithPLU.length} missing PLU codes to your menu cost file`);
                }
                if (unmatchedWithoutPLU.length > 0) {
                    debugLog(`   ‚ùì Assign PLU codes to ${unmatchedWithoutPLU.length} items in your POS system`);
                }
                debugLog(`   üìä PLU matching accuracy: ${unmatchedWithPLU.length === 0 ? '‚úÖ Perfect' : 'üîÑ Needs attention'}`);
                debugLog(`=====================================\n`);
            }
            
            // Group by category and calculate GP
            const categoryGroups = {};
            let processedItems = 0;
            
            matchedData.forEach(item => {
                const category = item.category || 'Uncategorized';
                
                if (!categoryGroups[category]) {
                    categoryGroups[category] = {
                        name: category,
                        sales: 0,
                        totalCost: 0,
                        items: 0,
                        pos_categories: [category],
                        itemDetails: []
                    };
                }
                
                const itemCost = item.cost * item.quantity;
                categoryGroups[category].sales += item.sales;
                categoryGroups[category].totalCost += itemCost;
                categoryGroups[category].items += 1;
                categoryGroups[category].itemDetails.push({
                    item: item.item,
                    sales: item.sales,
                    cost: itemCost,
                    quantity: item.quantity,
                    unitCost: item.cost,
                    matched: item.matchedWith,
                    matchScore: item.matchScore
                });
                
                processedItems++;
            });
            
            debugLog(`üìä Category Processing:`);
            debugLog(`   ‚Ä¢ ${processedItems} items processed into ${Object.keys(categoryGroups).length} categories`);
            
            // Convert to array and calculate GP percentages
            processedData = Object.values(categoryGroups).map(category => {
                const gp_rands = category.sales - category.totalCost;
                const gp_percent = category.sales > 0 ? (gp_rands / category.sales) * 100 : 0;
                
                return {
                    name: category.name,
                    sales: Math.round(category.sales),
                    cost: Math.round(category.totalCost),
                    gp_rands: Math.round(gp_rands),
                    gp_percent: Math.round(gp_percent * 10) / 10,
                    items: category.items,
                    pos_categories: category.pos_categories,
                    itemDetails: category.itemDetails
                };
            }).filter(category => category.sales > 0)
              .sort((a, b) => b.sales - a.sales);
            
            debugLog(`‚úÖ Analysis Complete: ${processedData.length} categories with sales data`);
            
            // Store analysis metadata for dashboard
            window.analysisMetadata = {
                totalSalesItems: salesData.length,
                actualMenuItems: actualMenuItems.length,
                modifierItems: modifierItems.length,
                matchedItems: matchedCount,
                unmatchedItems: unmatchedItems.length,
                unmatchedItemsList: unmatchedItems,
                modifierItemsList: modifierItems,
                modifierBreakdown: modifierItems.reduce((acc, item) => {
                    acc[item.type] = (acc[item.type] || 0) + 1;
                    return acc;
                }, {})
            };
        }

        function updateDashboard() {
            // Update summary stats
            const totalSales = processedData.reduce((sum, cat) => sum + cat.sales, 0);
            const totalGP = processedData.reduce((sum, cat) => sum + cat.gp_rands, 0);
            const overallGP = totalSales > 0 ? (totalGP / totalSales) * 100 : 0;
            
            // Get analysis metadata
            const metadata = window.analysisMetadata || {};
            const actualMenuItems = metadata.actualMenuItems || 0;
            const matchedItems = metadata.matchedItems || 0;
            const modifierItems = metadata.modifierItems || 0;
            const totalSalesItems = metadata.totalSalesItems || salesData.length;
            
            // Calculate mapping success rate for menu items only
            const menuItemMappingRate = actualMenuItems > 0 ? 
                ((matchedItems / actualMenuItems) * 100).toFixed(1) : 0;
            
            // Update stat cards
            const statCards = document.querySelectorAll('.stat-card');
            if (statCards[0]) statCards[0].querySelector('.stat-value').textContent = `${overallGP.toFixed(1)}%`;
            if (statCards[1]) statCards[1].querySelector('.stat-value').textContent = formatCurrency(totalSales);
            if (statCards[2]) statCards[2].querySelector('.stat-value').textContent = formatCurrency(totalGP);
            if (statCards[3]) {
                statCards[3].querySelector('.stat-value').textContent = `${menuItemMappingRate}%`;
                statCards[3].querySelector('.stat-label').textContent = `Menu Item Mapping (${matchedItems}/${actualMenuItems})`;
            }
            
            // Update category filter dropdown
            updateCategoryFilter();
            
            // Use processed data for display
            filteredData = [...processedData];
            renderCategories();
            
            // Enhanced dashboard logging
            debugLog(`üìä Dashboard Updated:`);
            debugLog(`   ‚Ä¢ Total POS Items: ${totalSalesItems}`);
            debugLog(`   ‚Ä¢ Items Processed: ${actualMenuItems} (no modifier filtering)`);
            debugLog(`   ‚Ä¢ Successfully Matched: ${matchedItems}`);
            debugLog(`   ‚Ä¢ Match Rate: ${menuItemMappingRate}%`);
            debugLog(`   ‚Ä¢ Categories Created: ${processedData.length}`);
            
            // Show modifier breakdown if available
            if (metadata.modifierBreakdown) {
                const breakdown = Object.entries(metadata.modifierBreakdown)
                    .map(([type, count]) => `${type}: ${count}`)
                    .join(', ');
                debugLog(`   ‚Ä¢ Modifier Types: ${breakdown}`);
            }
        }

        function updateCategoryFilter() {
            const categoryCheckboxes = document.getElementById('categoryCheckboxes');
            
            // Get unique categories from processed data
            const uniqueCategories = [...new Set(processedData.map(cat => cat.name))].sort();
            
            // Create checkboxes for each category
            categoryCheckboxes.innerHTML = uniqueCategories.map(category => {
                const salesAmount = processedData.find(cat => cat.name === category)?.sales || 0;
                const isZeroSales = salesAmount === 0;
                const checkboxId = `cat_${category.replace(/\s+/g, '_')}`;
                
                return `
                    <div style="margin-bottom: 5px; display: flex; align-items: center; ${isZeroSales ? 'opacity: 0.7;' : ''}">
                        <input type="checkbox" id="${checkboxId}" value="${category}" 
                               ${!isZeroSales ? 'checked' : ''} 
                               onchange="applyFilters()" 
                               style="margin-right: 8px;">
                        <label for="${checkboxId}" style="font-size: 0.9em; cursor: pointer; flex: 1;">
                            ${category} ${isZeroSales ? '(R0 sales)' : `(R${salesAmount.toLocaleString()})`}
                        </label>
                    </div>
                `;
            }).join('');
        }

        function selectAllCategories() {
            const checkboxes = document.querySelectorAll('#categoryCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            applyFilters();
        }

        function deselectAllCategories() {
            const checkboxes = document.querySelectorAll('#categoryCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            applyFilters();
        }

        function getSelectedCategories() {
            const checkboxes = document.querySelectorAll('#categoryCheckboxes input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }

        function updateUploadStatus(message) {
            document.getElementById('uploadStatus').textContent = message;
        }

        function debugLog(message) {
            const debugLog = document.getElementById('debugLog');
            const debugSection = document.getElementById('debugSection');
            const timestamp = new Date().toLocaleTimeString();
            debugLog.textContent += `[${timestamp}] ${message}\n`;
            debugSection.style.display = 'block';
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        function clearDebugLog() {
            document.getElementById('debugLog').textContent = '';
            document.getElementById('debugSection').style.display = 'none';
        }

        function showDataPreview(salesData, menuData) {
            const previewSection = document.getElementById('dataPreview');
            const previewContent = document.getElementById('previewContent');
            
            let html = '';
            
            if (salesData && salesData.length > 0) {
                const salesColumns = Object.keys(salesData[0]);
                html += `<div style="margin-bottom: 20px;">
                    <strong>üìä Sales Data (${salesData.length} rows)</strong><br>
                    <em>Columns: ${salesColumns.join(', ')}</em><br>
                    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-family: monospace; font-size: 0.8em;">
                        ${salesData.slice(0, 3).map(row => JSON.stringify(row, null, 2)).join('<br><hr style="margin: 10px 0;">')}
                    </div>
                </div>`;
            }
            
            if (menuData && menuData.length > 0) {
                const menuColumns = Object.keys(menuData[0]);
                html += `<div style="margin-bottom: 20px;">
                    <strong>üçΩÔ∏è Menu Data (${menuData.length} rows)</strong><br>
                    <em>Columns: ${menuColumns.join(', ')}</em><br>
                    <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-family: monospace; font-size: 0.8em;">
                        ${menuData.slice(0, 3).map(row => JSON.stringify(row, null, 2)).join('<br><hr style="margin: 10px 0;">')}
                    </div>
                </div>`;
            }
            
            previewContent.innerHTML = html;
            previewSection.style.display = 'block';
        }

        function hideDataPreview() {
            document.getElementById('dataPreview').style.display = 'none';
        }

        let rawSalesData = [];
        let rawMenuData = [];

        function showColumnMapping(salesData, menuData) {
            rawSalesData = salesData;
            rawMenuData = menuData;
            
            const mappingSection = document.getElementById('columnMapping');
            const mappingContent = document.getElementById('mappingContent');
            
            let html = '';
            
            // Sales Data Mapping
            if (salesData && salesData.length > 0) {
                const salesColumns = Object.keys(salesData[0]);
                html += `<div>
                    <h5 style="margin-bottom: 15px; color: #2c3e50;">üìä Sales Data Mapping</h5>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Item Name:</label>
                        <select id="salesItemColumn" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="">-- Select Column --</option>
                            ${salesColumns.map(col => `<option value="${col}" ${col === 'Menu_Item' ? 'selected' : ''}>${col}</option>`).join('')}
                        </select>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Category:</label>
                        <select id="salesCategoryColumn" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="">-- Select Column --</option>
                            ${salesColumns.map(col => `<option value="${col}" ${col === 'CATEGORY' ? 'selected' : ''}>${col}</option>`).join('')}
                        </select>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Sales Amount:</label>
                        <select id="salesAmountColumn" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="">-- Select Column --</option>
                            ${salesColumns.map(col => `<option value="${col}" ${col === 'SalesTotal_Excl__Tax1' ? 'selected' : ''}>${col}</option>`).join('')}
                        </select>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Quantity:</label>
                        <select id="salesQuantityColumn" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="">-- Select Column --</option>
                            ${salesColumns.map(col => `<option value="${col}" ${col === 'Quantity' ? 'selected' : ''}>${col}</option>`).join('')}
                        </select>
                    </div>
                </div>`;
            }
            
            // Menu Data Mapping
            if (menuData && menuData.length > 0) {
                const menuColumns = Object.keys(menuData[0]);
                html += `<div>
                    <h5 style="margin-bottom: 15px; color: #2c3e50;">üçΩÔ∏è Menu Data Mapping</h5>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Item Name:</label>
                        <select id="menuItemColumn" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="">-- Select Column --</option>
                            ${menuColumns.map(col => `<option value="${col}" ${col === 'Product' ? 'selected' : ''}>${col}</option>`).join('')}
                        </select>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Food Cost:</label>
                        <select id="menuCostColumn" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="">-- Select Column --</option>
                            ${menuColumns.map(col => `<option value="${col}" ${col.includes('Meal Cost') ? 'selected' : ''}>${col}</option>`).join('')}
                        </select>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Menu Price:</label>
                        <select id="menuPriceColumn" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="">-- Select Column --</option>
                            ${menuColumns.map(col => `<option value="${col}" ${col.includes('Menu Price') ? 'selected' : ''}>${col}</option>`).join('')}
                        </select>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Category (Optional):</label>
                        <select id="menuCategoryColumn" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="">-- Select Column --</option>
                            ${menuColumns.map(col => `<option value="${col}">${col}</option>`).join('')}
                        </select>
                    </div>
                </div>`;
            }
            
            mappingContent.innerHTML = html;
            mappingSection.style.display = 'block';
        }

        function hideColumnMapping() {
            document.getElementById('columnMapping').style.display = 'none';
        }

        function applyColumnMapping() {
            debugLog('Applying column mapping...');
            
            // Get selected mappings
            const salesMapping = {
                item: document.getElementById('salesItemColumn')?.value || '',
                category: document.getElementById('salesCategoryColumn')?.value || '',
                sales: document.getElementById('salesAmountColumn')?.value || '',
                quantity: document.getElementById('salesQuantityColumn')?.value || ''
            };
            
            const menuMapping = {
                item: document.getElementById('menuItemColumn')?.value || '',
                cost: document.getElementById('menuCostColumn')?.value || '',
                price: document.getElementById('menuPriceColumn')?.value || '',
                category: document.getElementById('menuCategoryColumn')?.value || ''
            };
            
            debugLog(`Sales mapping: ${JSON.stringify(salesMapping)}`);
            debugLog(`Menu mapping: ${JSON.stringify(menuMapping)}`);
            
            // Process data with custom mapping
            processSalesDataWithMapping(rawSalesData, salesMapping);
            processMenuDataWithMapping(rawMenuData, menuMapping);
            
            if (salesData.length === 0 && menuCostData.length === 0) {
                updateUploadStatus('‚ùå No valid data found with selected mappings. Please check your column selections.');
                return;
            }
            
            calculateGPAnalysis();
            
            if (processedData.length === 0) {
                updateUploadStatus('‚ùå Could not match sales data with menu costs. Check item names and try again.');
                return;
            }
            
            updateDashboard();
            hideColumnMapping();
            updateUploadStatus('‚úÖ Files processed successfully with custom mapping!');
            
            // Show analysis details button
            document.getElementById('analysisBtn').style.display = 'inline-block';
            
            // Show unmatched items button if there are unmatched items
            const metadata = window.analysisMetadata || {};
            if (metadata.unmatchedItems > 0) {
                document.getElementById('unmatchedBtn').style.display = 'inline-block';
            }
        }

        function processSalesDataWithMapping(data, mapping) {
            debugLog('Processing sales data with custom mapping...');
            
            salesData = data.map(row => {
                const item = row[mapping.item] || '';
                const category = row[mapping.category] || '';
                const sales = parseFloat(row[mapping.sales] || 0);
                const quantity = parseInt(row[mapping.quantity] || 0);
                
                return {
                    item: item.toString().trim(),
                    category: category.toString().trim(),
                    sales: isNaN(sales) ? 0 : sales,
                    quantity: isNaN(quantity) ? 0 : quantity,
                    price: sales / (quantity || 1),
                    originalRow: row
                };
            }).filter(item => item.item && (item.sales > 0 || item.quantity > 0));
            
            debugLog(`Processed ${salesData.length} sales records with custom mapping`);
        }

        function processMenuDataWithMapping(data, mapping) {
            debugLog('Processing menu data with custom mapping...');
            
            menuCostData = data.map(row => {
                const item = row[mapping.item] || '';
                const category = row[mapping.category] || '';
                
                // Helper function to parse currency values (handles R9.80, $10.50, etc.)
                const parseCurrency = (value) => {
                    if (!value) return 0;
                    const stringValue = value.toString().trim();
                    // Remove currency symbols and parse
                    const cleanValue = stringValue.replace(/[R$¬£‚Ç¨,\s]/g, '');
                    const parsed = parseFloat(cleanValue);
                    return isNaN(parsed) ? 0 : parsed;
                };
                
                const cost = parseCurrency(row[mapping.cost] || 0);
                const price = parseCurrency(row[mapping.price] || 0);
                
                return {
                    item: item.toString().trim(),
                    category: category.toString().trim(),
                    cost: isNaN(cost) ? 0 : cost,
                    price: isNaN(price) ? 0 : price,
                    originalRow: row
                };
            }).filter(item => item.item && item.cost > 0);
            
            debugLog(`Processed ${menuCostData.length} menu cost records with custom mapping`);
        }

        function showAnalysisDetails() {
            const metadata = window.analysisMetadata || {};
            const { totalSalesItems, actualMenuItems, modifierItems, matchedItems, unmatchedItems, modifierBreakdown, manualMatchesApplied } = metadata;
            
            // Create detailed analysis modal/section
            const detailsHtml = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center;">
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 800px; max-height: 80vh; overflow-y: auto; margin: 20px;">
                        <h3 style="margin-bottom: 20px; color: #2c3e50;">üìä Detailed Analysis Results</h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div style="padding: 15px; background: #f8f9fa; border-radius: 10px;">
                                <h4 style="color: #2c3e50; margin-bottom: 10px;">üìã Item Classification</h4>
                                <div style="font-size: 0.9em;">
                                    <div>Total POS Items: <strong>${totalSalesItems}</strong></div>
                                    <div>Actual Menu Items: <strong>${actualMenuItems}</strong></div>
                                    <div>Modifiers/Instructions: <strong>${modifierItems}</strong></div>
                                    <div>Successfully Matched: <strong>${matchedItems}</strong></div>
                                    <div>Unmatched Items: <strong>${unmatchedItems}</strong></div>
                                </div>
                            </div>
                            
                            <div style="padding: 15px; background: #e8f5e8; border-radius: 10px;">
                                <h4 style="color: #27ae60; margin-bottom: 10px;">üéØ Match Accuracy</h4>
                                <div style="font-size: 0.9em;">
                                    <div>Menu Item Match Rate: <strong>${actualMenuItems > 0 ? ((matchedItems/actualMenuItems)*100).toFixed(1) : 0}%</strong></div>
                                    <div>Items Processed: <strong>${matchedItems}</strong></div>
                                    <div>Categories Created: <strong>${processedData.length}</strong></div>
                                    ${manualMatchesApplied ? `<div>Manual Matches Applied: <strong style="color: #e67e22;">${manualMatchesApplied}</strong></div>` : ''}
                                    <div style="margin-top: 10px; color: #27ae60;">
                                        <strong>‚úÖ Analysis Quality: ${matchedItems > actualMenuItems * 0.7 ? 'Excellent' : matchedItems > actualMenuItems * 0.5 ? 'Good' : 'Needs Review'}</strong>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        ${modifierBreakdown ? `
                        <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border-radius: 10px;">
                            <h4 style="color: #856404; margin-bottom: 10px;">üîß Modifier Types Filtered</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; font-size: 0.9em;">
                                ${Object.entries(modifierBreakdown).map(([type, count]) => 
                                    `<div>${type.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}: <strong>${count}</strong></div>`
                                ).join('')}
                            </div>
                        </div>` : ''}
                        
                        <div style="margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 10px;">
                            <h4 style="color: #1976d2; margin-bottom: 10px;">üí° Quality Insights</h4>
                                                         <ul style="margin: 0; padding-left: 20px; font-size: 0.9em;">
                                 ${matchedItems > actualMenuItems * 0.8 ? 
                                     '<li style="color: #27ae60;">Excellent mapping! Your item names align well with menu costs.</li>' :
                                     '<li style="color: #e74c3c;">Consider reviewing unmatched items - there may be naming inconsistencies.</li>'
                                 }
                                 ${modifierItems > totalSalesItems * 0.3 ? 
                                     '<li style="color: #3498db;">Good! Many POS modifiers were correctly filtered out.</li>' :
                                     '<li style="color: #f39c12;">Most items appear to be actual menu items - verify if this is expected.</li>'
                                 }
                                 ${manualMatchesApplied ? 
                                     `<li style="color: #e67e22;">Great! You've manually matched ${manualMatchesApplied} items for improved accuracy.</li>` : ''
                                 }
                                 <li style="color: #2c3e50;">Categories with zero sales have been automatically unchecked in filters.</li>
                                 <li style="color: #2c3e50;">Use the detailed breakdown to verify cost calculations are accurate.</li>
                             </ul>
                        </div>
                        
                        <div style="text-align: center;">
                            <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                                    style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to DOM
            document.body.insertAdjacentHTML('beforeend', detailsHtml);
        }

        function showUnmatchedItems() {
            const metadata = window.analysisMetadata || {};
            const { unmatchedItemsList = [], modifierItemsList = [] } = metadata;
            
            // Sort unmatched items by sales value (highest first)
            const sortedUnmatched = unmatchedItemsList.sort((a, b) => b.sales - a.sales);
            
            // Group by category for better organization
            const unmatchedByCategory = sortedUnmatched.reduce((acc, item) => {
                const category = item.category || 'Uncategorized';
                if (!acc[category]) acc[category] = [];
                acc[category].push(item);
                return acc;
            }, {});
            
            // Calculate totals
            const totalUnmatchedSales = sortedUnmatched.reduce((sum, item) => sum + item.sales, 0);
            const totalUnmatchedQuantity = sortedUnmatched.reduce((sum, item) => sum + item.quantity, 0);
            
            // Function to find potential matches for manual matching
            function findPotentialMatches(pluItem) {
                if (!menuCostData || menuCostData.length === 0) return [];
                
                const pluWords = pluItem.toLowerCase().split(/\s+/).filter(w => w.length > 2);
                
                return menuCostData.map(menuItem => {
                    const menuWords = menuItem.item.toLowerCase().split(/\s+/);
                    
                    // Calculate similarity score
                    let score = 0;
                    
                    // Exact word matches
                    const exactMatches = pluWords.filter(word => 
                        menuWords.some(menuWord => menuWord.includes(word) || word.includes(menuWord))
                    );
                    score += exactMatches.length * 2;
                    
                    // Partial matches
                    pluWords.forEach(word => {
                        menuWords.forEach(menuWord => {
                            if (word.length > 3 && menuWord.length > 3) {
                                const commonChars = [...word].filter(char => menuWord.includes(char)).length;
                                score += commonChars / Math.max(word.length, menuWord.length);
                            }
                        });
                    });
                    
                    return {
                        menuItem,
                        score,
                        similarity: Math.min(score * 20, 100) // Convert to percentage
                    };
                })
                .filter(match => match.similarity > 15) // Only show reasonable matches
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, 5); // Top 5 matches
            }
            
            const unmatchedHtml = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center;">
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 900px; max-height: 80vh; overflow-y: auto; margin: 20px;">
                        <h3 style="margin-bottom: 20px; color: #2c3e50;">‚ùå Unmatched Menu Items</h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                            <div style="padding: 15px; background: #fef5e7; border-radius: 10px; text-align: center;">
                                <div style="font-size: 1.5em; font-weight: bold; color: #e67e22;">${sortedUnmatched.length}</div>
                                <div style="font-size: 0.9em; color: #d35400;">Unmatched Items</div>
                            </div>
                            <div style="padding: 15px; background: #fdedec; border-radius: 10px; text-align: center;">
                                <div style="font-size: 1.5em; font-weight: bold; color: #e74c3c;">R${totalUnmatchedSales.toLocaleString()}</div>
                                <div style="font-size: 0.9em; color: #c0392b;">Lost Sales Value</div>
                            </div>
                            <div style="padding: 15px; background: #f4f6f6; border-radius: 10px; text-align: center;">
                                <div style="font-size: 1.5em; font-weight: bold; color: #7f8c8d;">${totalUnmatchedQuantity.toLocaleString()}</div>
                                <div style="font-size: 0.9em; color: #566573;">Total Quantity</div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 20px; padding: 15px; background: #eaf2f8; border-radius: 10px;">
                            <h4 style="color: #2c3e50; margin-bottom: 10px;">üí° Why Items Might Be Unmatched</h4>
                            <ul style="margin: 0; padding-left: 20px; font-size: 0.9em; color: #2c3e50;">
                                <li>Different naming conventions between POS and menu cost data</li>
                                <li>Items might exist in sales but not in menu cost file</li>
                                <li>Spelling differences, abbreviations, or extra words</li>
                                <li>New items added to POS but not yet costed</li>
                                <li>Seasonal or discontinued items</li>
                            </ul>
                        </div>
                        
                        <div style="max-height: 500px; overflow-y: auto; border: 1px solid #ddd; border-radius: 10px;">
                            ${Object.entries(unmatchedByCategory).map(([category, items]) => `
                                <div style="border-bottom: 1px solid #eee;">
                                    <div style="padding: 10px 15px; background: #f8f9fa; font-weight: bold; color: #2c3e50; border-bottom: 1px solid #ddd;">
                                        üìÇ ${category} (${items.length} items)
                                    </div>
                                    ${items.map((item, itemIndex) => {
                                        const potentialMatches = findPotentialMatches(item.item);
                                        const uniqueId = `${category}_${itemIndex}`;
                                        
                                        return `
                                        <div style="padding: 12px 15px; border-bottom: 1px solid #f1f2f6;">
                                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr; gap: 10px; align-items: center; font-size: 0.9em; margin-bottom: 8px;">
                                                <div style="font-weight: 500; color: #2c3e50;">${item.item}</div>
                                                <div style="text-align: right; color: #27ae60;">R${item.sales.toLocaleString()}</div>
                                                <div style="text-align: right; color: #3498db;">${item.quantity}</div>
                                                <div style="text-align: right; color: #9b59b6;">R${(item.sales/item.quantity || 0).toFixed(2)}/unit</div>
                                            </div>
                                            ${potentialMatches.length > 0 ? `
                                                <div style="margin-top: 8px; padding: 8px; background: #f8f9fa; border-radius: 5px;">
                                                    <label style="font-size: 0.8em; color: #7f8c8d; margin-bottom: 5px; display: block;">üí° Suggested Matches:</label>
                                                    <select id="match_${uniqueId}" style="width: 100%; padding: 4px; font-size: 0.8em; border: 1px solid #ddd; border-radius: 3px;" onchange="updateMatchPreview('${uniqueId}')">
                                                        <option value="">-- Select a match --</option>
                                                        ${potentialMatches.map(match => `
                                                            <option value="${match.menuItem.item}" data-cost="${match.menuItem.cost}" data-price="${match.menuItem.price}">
                                                                ${match.menuItem.item} (${match.similarity.toFixed(0)}% match) - Cost: R${match.menuItem.cost.toFixed(2)}
                                                            </option>
                                                        `).join('')}
                                                        <option value="NO_MATCH">‚ùå No suitable match</option>
                                                    </select>
                                                    <div id="preview_${uniqueId}" style="font-size: 0.8em; color: #27ae60; margin-top: 4px; display: none;"></div>
                                                </div>
                                            ` : `
                                                <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border-radius: 5px; font-size: 0.8em; color: #856404;">
                                                    ‚ùì No similar items found in menu cost data
                                                    <select id="match_${uniqueId}" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 0.8em;">
                                                        <option value="">-- No matches available --</option>
                                                        <option value="NO_MATCH">‚ùå Mark as no match</option>
                                                    </select>
                                                </div>
                                            `}
                                        </div>
                                        `;
                                    }).join('')}
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 10px;">
                            <h4 style="color: #856404; margin-bottom: 10px;">üîß Next Steps</h4>
                            <ul style="margin: 0; padding-left: 20px; font-size: 0.9em; color: #856404;">
                                <li>Review high-value unmatched items first (sorted by sales)</li>
                                <li>Check if these items exist in your menu cost data with different names</li>
                                <li>Consider adding missing items to your menu cost file</li>
                                <li>Use consistent naming between POS and menu cost systems</li>
                                <li>Focus on items with significant sales impact</li>
                            </ul>
                        </div>
                        
                        <div style="text-align: center; margin-top: 20px; display: flex; gap: 10px; justify-content: center;">
                            <button onclick="applyManualMatches()" 
                                    style="padding: 10px 20px; background: #27ae60; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                                üîó Apply Manual Matches
                            </button>
                            <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                                    style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to DOM
            document.body.insertAdjacentHTML('beforeend', unmatchedHtml);
        }

        // Global variable to store manual matches
        let manualMatches = {};

        function updateMatchPreview(uniqueId) {
            const select = document.getElementById(`match_${uniqueId}`);
            const preview = document.getElementById(`preview_${uniqueId}`);
            
            if (select.value && select.value !== 'NO_MATCH') {
                const selectedOption = select.options[select.selectedIndex];
                const cost = selectedOption.getAttribute('data-cost');
                const price = selectedOption.getAttribute('data-price');
                
                preview.innerHTML = `‚úÖ Will match to: ${select.value} | Cost: R${cost} | Price: R${price}`;
                preview.style.display = 'block';
            } else if (select.value === 'NO_MATCH') {
                preview.innerHTML = `‚ùå Will be excluded from analysis`;
                preview.style.display = 'block';
                preview.style.color = '#e74c3c';
            } else {
                preview.style.display = 'none';
            }
        }

        function applyManualMatches() {
            const metadata = window.analysisMetadata || {};
            const { unmatchedItemsList = [] } = metadata;
            
            // Collect all manual matches from the form
            manualMatches = {};
            let matchCount = 0;
            let noMatchCount = 0;
            
            // Go through each unmatched item and check if user selected a match
            unmatchedItemsList.forEach((item, index) => {
                const category = item.category || 'Uncategorized';
                const uniqueId = `${category}_${index}`;
                const select = document.getElementById(`match_${uniqueId}`);
                
                if (select && select.value) {
                    if (select.value === 'NO_MATCH') {
                        noMatchCount++;
                    } else {
                        // Find the actual menu item data
                        const menuItem = menuCostData.find(m => m.item === select.value);
                        if (menuItem) {
                            manualMatches[item.item] = menuItem;
                            matchCount++;
                        }
                    }
                }
            });
            
            if (matchCount === 0) {
                alert('‚ùå No manual matches selected. Please select at least one match to apply.');
                return;
            }
            
            // Show processing message
            updateUploadStatus(`üîÑ Applying ${matchCount} manual matches and reprocessing...`);
            
            // Close the modal
            document.querySelector('[style*="position: fixed"]').remove();
            
            // Rerun analysis with manual matches
            setTimeout(() => {
                calculateGPAnalysisWithManualMatches();
                updateDashboard();
                updateUploadStatus(`‚úÖ Analysis updated with ${matchCount} manual matches applied!`);
                debugLog(`üìù Applied ${matchCount} manual matches, excluded ${noMatchCount} items`);
            }, 100);
        }

        function calculateGPAnalysisWithManualMatches() {
            debugLog('üîÑ Recalculating GP analysis with manual matches...');
            
            // Process all sales items as menu items (no modifier filtering)
            const actualMenuItems = [...salesData];
            const modifierItems = []; // Keep empty for compatibility
            const unmatchedItems = [];
            
            // Process matches including manual matches
            let matchedCount = 0;
            const matchedData = actualMenuItems.map(saleItem => {
                let menuItem = null;
                let matchScore = 0;
                let matchType = 'none';
                
                // First check if there's a manual match
                if (manualMatches[saleItem.item]) {
                    menuItem = manualMatches[saleItem.item];
                    matchScore = 1.0;
                    matchType = 'manual';
                } else {
                    // Prioritize PLU code matching
                    if (saleItem.pluCode && saleItem.pluCode.trim() !== '') {
                        menuItem = menuCostData.find(menuItem => 
                            menuItem.pluCode && menuItem.pluCode.trim() === saleItem.pluCode.trim()
                        );
                        if (menuItem) {
                            matchScore = 1.0;
                            matchType = 'PLU';
                            debugLog(`üéØ PLU match: ${saleItem.item} (PLU: ${saleItem.pluCode}) ‚Üí ${menuItem.item}`);
                        }
                    }
                    
                    // Fall back to exact name match only if no PLU match
                    if (!menuItem) {
                        menuItem = menuCostData.find(menuItem => 
                            menuItem.item.toLowerCase().trim() === saleItem.item.toLowerCase().trim()
                        );
                        if (menuItem) {
                            matchScore = 0.9;
                            matchType = 'exact';
                        }
                    }
                    
                    // Note: Removed fuzzy matching to avoid incorrect pairings
                }
                
                if (menuItem && matchScore >= 0.8) {
                    matchedCount++;
                    debugLog(`‚úÖ ${matchType} match: "${saleItem.item}" ‚Üí "${menuItem.item}"`);
                    
                    return {
                        ...saleItem,
                        cost: menuItem.cost,
                        menuPrice: menuItem.price,
                        matched: true,
                        matchedWith: menuItem.item,
                        matchScore: matchScore,
                        matchType: matchType
                    };
                } else {
                    unmatchedItems.push(saleItem);
                    return null;
                }
            }).filter(item => item !== null);
            
            debugLog(`üéØ Enhanced Matching Results (with manual matches):`);
            debugLog(`   ‚Ä¢ ${matchedCount}/${actualMenuItems.length} menu items matched`);
            debugLog(`   ‚Ä¢ ${Object.keys(manualMatches).length} manual matches applied`);
            
            // Continue with same category processing as before
            const categoryGroups = {};
            let processedItems = 0;
            
            matchedData.forEach(item => {
                const category = item.category || 'Uncategorized';
                
                if (!categoryGroups[category]) {
                    categoryGroups[category] = {
                        name: category,
                        sales: 0,
                        totalCost: 0,
                        items: 0,
                        pos_categories: [category],
                        itemDetails: []
                    };
                }
                
                const itemCost = item.cost * item.quantity;
                categoryGroups[category].sales += item.sales;
                categoryGroups[category].totalCost += itemCost;
                categoryGroups[category].items += 1;
                categoryGroups[category].itemDetails.push({
                    item: item.item,
                    sales: item.sales,
                    cost: itemCost,
                    quantity: item.quantity,
                    unitCost: item.cost,
                    matched: item.matchedWith,
                    matchScore: item.matchScore,
                    matchType: item.matchType
                });
                
                processedItems++;
            });
            
            // Update processed data
            processedData = Object.values(categoryGroups).map(category => {
                const gp_rands = category.sales - category.totalCost;
                const gp_percent = category.sales > 0 ? (gp_rands / category.sales) * 100 : 0;
                
                return {
                    name: category.name,
                    sales: Math.round(category.sales),
                    cost: Math.round(category.totalCost),
                    gp_rands: Math.round(gp_rands),
                    gp_percent: Math.round(gp_percent * 10) / 10,
                    items: category.items,
                    pos_categories: category.pos_categories,
                    itemDetails: category.itemDetails
                };
            }).filter(category => category.sales > 0)
              .sort((a, b) => b.sales - a.sales);
            
            // Update metadata
            window.analysisMetadata = {
                totalSalesItems: salesData.length,
                actualMenuItems: actualMenuItems.length,
                modifierItems: modifierItems.length,
                matchedItems: matchedCount,
                unmatchedItems: unmatchedItems.length,
                unmatchedItemsList: unmatchedItems,
                modifierItemsList: modifierItems,
                manualMatchesApplied: Object.keys(manualMatches).length,
                modifierBreakdown: modifierItems.reduce((acc, item) => {
                    acc[item.type] = (acc[item.type] || 0) + 1;
                    return acc;
                }, {})
            };
            
            debugLog(`‚úÖ Enhanced Analysis Complete: ${processedData.length} categories with ${Object.keys(manualMatches).length} manual matches`);
        }

        function loadSampleData() {
            // Reset to sample data
            filteredData = [...categoryData];
            renderCategories();
            
            // Clear any manual matches
            manualMatches = {};
            
            // Hide analysis buttons (only relevant for uploaded data)
            document.getElementById('analysisBtn').style.display = 'none';
            document.getElementById('unmatchedBtn').style.display = 'none';
            
            // Reset summary stats to sample data
            const statCards = document.querySelectorAll('.stat-card');
            if (statCards[0]) statCards[0].querySelector('.stat-value').textContent = '58.5%';
            if (statCards[1]) statCards[1].querySelector('.stat-value').textContent = 'R27,920';
            if (statCards[2]) statCards[2].querySelector('.stat-value').textContent = 'R16,333';
            if (statCards[3]) statCards[3].querySelector('.stat-value').textContent = '93.2%';
            
            updateUploadStatus('‚úÖ Sample data loaded');
            debugLog('Sample data loaded for demonstration');
        }

        function getGPClass(gp_percent) {
            if (gp_percent >= 70) return 'gp-high';
            if (gp_percent >= 50) return 'gp-medium';
            return 'gp-low';
        }

        function formatCurrency(amount) {
            return `R${amount.toLocaleString()}`;
        }

        function renderCategories() {
            const container = document.getElementById('categoryList');
            container.innerHTML = '';

            if (filteredData.length === 0) {
                container.innerHTML = '<div class="loading">No categories match the current filters.</div>';
                return;
            }

            filteredData.forEach((category, index) => {
                const categoryRow = document.createElement('div');
                categoryRow.className = 'category-row';
                categoryRow.onclick = () => toggleExpand(index);

                const gpBarWidth = Math.min(category.gp_percent, 100);
                const gpClass = getGPClass(category.gp_percent);

                categoryRow.innerHTML = `
                    <div class="category-info">
                        <div class="category-name">${category.name}</div>
                        <div class="category-details">${category.items} items | POS: ${category.pos_categories.join(', ')}</div>
                    </div>
                    <div class="category-metrics">
                        <div class="metric">
                            <div class="metric-value">${formatCurrency(category.sales)}</div>
                            <div class="metric-label">Sales</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${category.gp_percent.toFixed(1)}%</div>
                            <div class="metric-label">GP%</div>
                        </div>
                        <div class="gp-bar">
                            <div class="gp-fill ${gpClass}" style="width: ${gpBarWidth}%"></div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${formatCurrency(category.gp_rands)}</div>
                            <div class="metric-label">GP Rands</div>
                        </div>
                    </div>
                `;

                const expandableContent = document.createElement('div');
                expandableContent.className = 'expandable-content';
                expandableContent.id = `expand-${index}`;
                expandableContent.innerHTML = `
                    <h4>Category Details:</h4>
                    <div style="margin-bottom: 15px;">
                        <strong>Summary:</strong><br>
                        Total Sales: ${formatCurrency(category.sales)}<br>
                        Total Cost: ${formatCurrency(category.cost || 0)}<br>
                        GP Amount: ${formatCurrency(category.gp_rands)}<br>
                        GP Percentage: ${category.gp_percent}%<br>
                        Items: ${category.items}
                    </div>
                    ${category.itemDetails ? `
                        <h4>Item Breakdown:</h4>
                        <div style="max-height: 200px; overflow-y: auto;">
                            ${category.itemDetails.slice(0, 10).map(item => `
                                <div style="margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 5px; font-size: 0.9em;">
                                    <strong>${item.item}</strong><br>
                                    Sales: ${formatCurrency(item.sales)} | Cost: ${formatCurrency(item.cost)} | Qty: ${item.quantity}<br>
                                    <em>Matched with: ${item.matched || 'No match'}</em>
                                </div>
                            `).join('')}
                            ${category.itemDetails.length > 10 ? `<div style="text-align: center; color: #666; font-style: italic;">... and ${category.itemDetails.length - 10} more items</div>` : ''}
                        </div>
                    ` : `
                        <h4>POS Categories:</h4>
                        ${category.pos_categories.map(pos => `
                            <div class="pos-category">
                                <span><strong>${pos}</strong></span>
                                <span>Part of ${category.name}</span>
                            </div>
                        `).join('')}
                    `}
                `;

                container.appendChild(categoryRow);
                container.appendChild(expandableContent);
            });
        }

        function toggleExpand(index) {
            const content = document.getElementById(`expand-${index}`);
            content.classList.toggle('show');
        }

        function applyFilters() {
            const selectedCategories = getSelectedCategories();
            const gpFilter = document.getElementById('gpFilter').value;
            const salesFilter = parseFloat(document.getElementById('salesFilter').value) || 0;
            const sortBy = document.getElementById('sortBy').value;

            // Use processedData as the base, not categoryData (which is sample data)
            const baseData = processedData.length > 0 ? processedData : categoryData;

            // Filter by selected categories
            filteredData = baseData.filter(category => {
                // Filter by selected categories
                if (selectedCategories.length > 0 && !selectedCategories.includes(category.name)) return false;
                
                // Filter by GP range
                if (gpFilter === 'high' && category.gp_percent < 70) return false;
                if (gpFilter === 'medium' && (category.gp_percent < 50 || category.gp_percent >= 70)) return false;
                if (gpFilter === 'low' && category.gp_percent >= 50) return false;
                
                // Filter by minimum sales
                if (category.sales < salesFilter) return false;
                
                return true;
            });

            // Sort the filtered data
            filteredData.sort((a, b) => {
                switch (sortBy) {
                    case 'sales':
                        return b.sales - a.sales;
                    case 'gp_percent':
                        return b.gp_percent - a.gp_percent;
                    case 'gp_rands':
                        return b.gp_rands - a.gp_rands;
                    case 'name':
                        return a.name.localeCompare(b.name);
                    default:
                        return b.sales - a.sales;
                }
            });

            renderCategories();
        }

        function resetFilters() {
            // Check all category checkboxes except those with zero sales
            const checkboxes = document.querySelectorAll('#categoryCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const label = cb.nextElementSibling.textContent;
                cb.checked = !label.includes('(R0 sales)'); // Uncheck zero sales categories
            });
            
            document.getElementById('gpFilter').value = 'all';
            document.getElementById('salesFilter').value = '';
            document.getElementById('sortBy').value = 'sales';
            applyFilters();
        }

        // Event listeners  
        document.getElementById('gpFilter').addEventListener('change', applyFilters);
        document.getElementById('salesFilter').addEventListener('input', applyFilters);
        document.getElementById('sortBy').addEventListener('change', applyFilters);

        // Initial setup and library check
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('Page loaded, initializing...');
            
            // Check if XLSX library is available
            setTimeout(() => {
                if (typeof XLSX === 'undefined') {
                    debugLog('‚ùå XLSX library not loaded after page load');
                    updateUploadStatus('‚ùå XLSX library failed to load. Please refresh the page and check your internet connection.');
                } else {
                    debugLog('‚úÖ XLSX library loaded successfully');
                    updateUploadStatus('Ready to upload files');
                }
            }, 1000);
            
            // Add file upload event listeners
            document.getElementById('salesFile').addEventListener('change', handleFileUpload);
            document.getElementById('menuFile').addEventListener('change', handleFileUpload);
            
            // Initial render
            renderCategories();
            debugLog('Initial dashboard rendered');
        });
    </script>
</body>
</html>